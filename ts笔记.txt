TypeScript基础快速入门
快速入门及复习回顾TypeScript知识点

1、TypeScript简介
TypeScript是JavaScript的超集。

它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。

TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。

TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。

相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。

2、TypeScript 开发环境搭建
下载Node.js

64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi
32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi
安装Node.js

使用npm全局安装typescript

进入命令行
输入：npm i -g typescript
创建一个ts文件

使用tsc对ts文件进行编译

进入命令行
进入ts文件所在目录
执行命令：tsc xxx.ts
---------------------------------------------------------------
3、基本类型
类型声明

类型声明是TS非常重要的一个特点

通过类型声明可以指定TS中变量（参数、形参）的类型

指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错

简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值

语法：
let 变量: 类型;

let 变量: 类型 = 值;

function fn(参数: 类型, 参数: 类型): 类型{
    ...
}
----------------------------------------------------------
自动类型判断

TS拥有自动的类型判断机制
当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型
所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明
--------------------------------------------------------------------
类型：

类型	                例子	                                                     描述
number	             1, -33, 2.5	                                               任意数字
string	            ‘hi’, “hi”, hi	                                               任意字符串
boolean         	true、false	                                               布尔值true或false
字面量	            其本身	                                               限制变量的值就是该字面量的值
any	                  *	                                                           任意类型
unknown	              *	                                                         类型安全的any
void	            空值（undefined）	                                       没有值（或undefined）
never	            没有值	                                                      不能是任何值
object	            {name:‘孙悟空’}                                               任意的JS对象
array	            [1,2,3]	                                                       任意JS数组
tuple	            [4,5]	                                               元素，TS新增类型，固定长度数组
enum	            enum{A, B}	                                               枚举，TS中新增类型
----------------------------------------
number
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n;

boolean
let isDone: boolean = false;

string
let color: string = "blue";
color = 'red';

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}.
I'll be ${age + 1} years old next month.`;

字面量
也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围
let color: 'red' | 'blue' | 'black';
let num: 1 | 2 | 3 | 4 | 5;

any
let d: any = 4;
d = 'hello';
d = true;

unknown
let notSure: unknown = 4;
notSure = 'hello';
// unknown实际上,就是一个类型安全的any
// unknown类型的变量，不能直接赋值给别的类型
let e = "hi";
if (typeof e === "string") s = e;
s = e as string;
s = <string>e;

void
let unusable: void = undefined;
// void 用来表示空，以函数为例，就表示没返回值(空值undefined)的函数
function fn(): void {
  return undefined;
}

never
// never 表示永远不会返回结果
function fn2(): never {
  //   return undefined;  //报错
  throw new Error("报错了");
}

object（没啥用）
let obj: object = {};
// {} 用来指定对象中可以包含哪些属性
// 语法：{属性名:属性值, ... ,属性名:属性值}
// 属性名后加一个'?'表示可选属性
let b: { name: string; age?: number };
// b = {}; // 报错
b = { name: "xzq", age: 18 };
// [propName: string]: any   表示任意类型的属性,且后面可以接任意个
let c: { name: string; [propName: string]: any };
c = { name: "xzq", age: 18, a: '1' };


array
/**
 * 数组类型的声明
 *      类型[]
 *      Array<类型>
 */
let list: number[] = [1, 2, 3];
let list: Array<number> = [1, 2, 3];

tuple
let x: [string, number];
x = ["hello", 10]; 

enum
enum Color {
  Red,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green = 2,
  Blue = 4,
}
let c: Color = Color.Green;


类型断言
有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，这样的话那么就可以将unknown类型的变量赋值给其他同类型变量了，断言有两种形式：

/**
 *      变量 as 类型
 *      <类型>变量
 */
第一种
let someValue: unknown = "this is a string";
let strLength: number = (someValue as string).length;
第二种
let someValue: unknown = "this is a string";
let strLength: number = (<string>someValue).length;

&表示同时
// &表示同时
// let j: { name: string; age: number }; //和下面等价
let j: { name: string } & { age: number };
j = { name: "xzq", age: 18 };

类型别名
// 类型别名
type myType = 1 | 2 | 3 | 4 | 5;
// let k: 1 | 2 | 3 | 4 | 5;
// let l: 1 | 2 | 3 | 4 | 5;
let k: myType;
let l: myType;
k = 5;

函数
/**
 * 设置函数的结构的类型声明
 *      语法：(形参:类型, ... ,形参:类型) => 返回值类型
 */
let d: (a: number, b: number) => number;
d = function (n1, n2): number {
  return n1 + n2;
};

自动编译文件（命令）
编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。

示例：
tsc xxx.ts -w

自动编译整个项目
如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。

但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json

也可以使用终端命令创建配置文件 tsconfig.json
tsc -init
tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译
配置选项：

include
定义希望被编译文件所在的目录

默认值：[“**/*”]

示例：
/* 路径：** 表示任意目录
            *  表示任意文件
*/
"include":["src/**/*", "tests/**/*"]

上述示例中，所有src目录和tests目录下的文件都会被编译

exclude
定义需要排除在外的目录

默认值：[“node_modules”, “bower_components”, “jspm_packages”]

示例：
"exclude": ["./src/hello/**/*"]
上述示例中，src下hello目录下的文件都不会被编译

extends
定义被继承的配置文件

示例：
"extends": "./configs/base"
上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息


